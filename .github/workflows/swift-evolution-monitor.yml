name: Swift Evolution Monitor

on:
  workflow_dispatch:
    inputs:
      since_date:
        description: '監視開始日（YYYY-MM-DD形式、空の場合は1日前から）'
        required: false
        default: ''
        type: string
  schedule:
    - cron: '0 6 * * *'  # 毎日日本時間15時（UTC 6時）

jobs:
  monitor-swift-evolution:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Get Swift Evolution Changes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 監視開始日を決定
          if [ -n "${{ github.event.inputs.since_date }}" ]; then
            # 入力値のバリデーション（YYYY-MM-DD形式のみ許可）
            INPUT_DATE="${{ github.event.inputs.since_date }}"
            if [[ ! "$INPUT_DATE" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
              echo "Error: Invalid date format. Use YYYY-MM-DD format."
              exit 1
            fi
            
            # 手動実行時: 指定された日付を日本時間として扱い、UTC に変換
            JST_DATE="$INPUT_DATE 00:00:00"
            SINCE_DATE=$(TZ=Asia/Tokyo date -d "$JST_DATE" -u +"%Y-%m-%dT%H:%M:%SZ")
            echo "Manual execution: Checking commits since $INPUT_DATE JST ($SINCE_DATE UTC)"
          else
            # 自動実行時: 1日前を使用
            SINCE_DATE=$(date -d "1 day ago" -u +"%Y-%m-%dT%H:%M:%SZ")
            echo "Scheduled execution: Checking commits since yesterday"
          fi
          
          echo "Checking commits since: $SINCE_DATE"
          
          # コミット情報を取得
          gh api "repos/swiftlang/swift-evolution/commits?since=${SINCE_DATE}" > commits.json
          
          # proposals ディレクトリの変更をチェック
          echo "[]" > proposals_changes.json
          
          for sha in $(cat commits.json | jq -r '.[].sha'); do
            echo "Checking commit: $sha"
            
            # このコミットで変更された proposals ファイルを取得
            gh api "repos/swiftlang/swift-evolution/commits/$sha" \
              --jq '.files[] | select(.filename | startswith("proposals/"))' \
              >> proposals_changes_temp.json
          done
          
          # 全ての変更を統合（空ファイル対策も含む）
          if [ -s proposals_changes_temp.json ]; then
            cat proposals_changes_temp.json | jq -s 'unique_by(.filename)' > proposals_changes.json
          fi
          rm -f proposals_changes_temp.json
          
          # Accept/Implement されたプロポーザルを特定
          echo "[]" > accepted_proposals.json
          
          for filename in $(cat proposals_changes.json | jq -r '.[].filename' | sort -u); do
            echo "Checking status for: $filename"
            
            # プロポーザルファイルの内容を取得
            CONTENT=$(gh api "repos/swiftlang/swift-evolution/contents/$filename" --jq '.download_url' | xargs curl -s)
            
            # ステータスを抽出（Accepted または Implemented のみ）
            STATUS=$(echo "$CONTENT" | grep -i "^- Status:" | head -1 | sed 's/.*Status:[[:space:]]*//' | sed 's/\*\*//g' | tr -d ' ')
            
            if [[ "$STATUS" =~ ^(Accepted|Implemented)$ ]]; then
              # プロポーザル情報を抽出
              TITLE=$(echo "$CONTENT" | grep "^#" | head -1 | sed 's/^#[[:space:]]*//')
              PROPOSAL_NUM=$(echo "$CONTENT" | grep -E "^- Proposal:" | head -1 | sed 's/.*\[\([^]]*\)\].*/\1/')
              AUTHORS=$(echo "$CONTENT" | grep "^- Authors:" | head -1 | sed 's/^- Authors:[[:space:]]*//')
              
              # JSON エントリを作成
              cat <<EOF >> accepted_proposals_temp.json
{
  "filename": "$filename",
  "status": "$STATUS",
  "title": "$TITLE",
  "proposal_number": "$PROPOSAL_NUM",
  "authors": "$AUTHORS",
  "content": $(echo "$CONTENT" | jq -Rs .)
}
EOF
              echo "Found $STATUS proposal: $PROPOSAL_NUM - $TITLE"
            fi
          done
          
          # JSON 配列にまとめる
          if [ -f accepted_proposals_temp.json ]; then
            cat accepted_proposals_temp.json | jq -s '.' > accepted_proposals.json
            rm -f accepted_proposals_temp.json
          fi
          
          echo "Accepted/Implemented proposals found:"
          cat accepted_proposals.json

      - name: Analyze and Notify
        uses: google-gemini/gemini-cli-action@main
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_TEAM_ID: ${{ secrets.SLACK_TEAM_ID }}
        with:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          settings_json: |
            {
              "mcpServers": {
                "slack": {
                  "command": "npx",
                  "args": ["-y", "@modelcontextprotocol/server-slack"],
                  "env": {
                    "SLACK_BOT_TOKEN": "$SLACK_BOT_TOKEN",
                    "SLACK_TEAM_ID": "$SLACK_TEAM_ID"
                  }
                }
              },
              "coreTools": [
                "mcp__slack__slack_post_message",
                "read_file",
                "run_shell_command(cat)",
                "run_shell_command(ls)"
              ]
            }
          prompt: |
            あなたは Swift Evolution プロポーザルの要約アシスタントです。
            この処理は定期実行しているためユーザへの確認は不要です。

            前のステップで Accept または Implement されたプロポーザルが特定されています。
            以下のファイルから情報を読み取って、該当プロポーザルの Slack 通知を作成してください：

            ## 1. 対象プロポーザルの確認

            ```bash
            cat accepted_proposals.json
            ```

            ## 2. Slack 通知の作成

            accepted_proposals.json に含まれる各プロポーザルについて、
            Slack の `#general` チャンネルに以下の形式で個別に投稿してください：

            ```
            🚀 Swift Evolution Update

            **{proposal_number}: {title}**
            📋 Status: **✅ Accepted** または **🛠 Implemented**
            👤 Author: {authors}
            🔗 <https://github.com/swiftlang/swift-evolution/blob/main/proposals/{filename}|詳細を見る>

            📝 **要約:**
            [プロポーザルのcontentフィールドの内容を600字程度で要約してください。以下の観点を含めてください：
            - 何を解決しようとしているのか（Motivation）
            - どのような解決策を提案しているのか（Proposed Solution）
            - Swift 開発者にとってのメリット
            - 具体的な使用例があれば簡潔に紹介]
            ```

            ## 3. 対象外の場合

            accepted_proposals.json が空配列の場合は、Slack への投稿は行わず処理を終了してください。

            ## 注意事項

            - 複数のプロポーザルがある場合は、それぞれ個別に投稿する
            - JSON内の情報をそのまま使用し、推測や補完は行わない
